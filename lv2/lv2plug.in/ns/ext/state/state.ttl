# LV2 State Extension
# Copyright 2010-2012 David Robillard <d@drobilla.net>
# Copyright 2010 Leonard Ritter <paniq@paniq.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

@prefix dcs:   <http://ontologi.es/doap-changeset#> .
@prefix doap:  <http://usefulinc.com/ns/doap#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .
@prefix lv2:   <http://lv2plug.in/ns/lv2core#> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .
@prefix state: <http://lv2plug.in/ns/ext/state#> .

<http://drobilla.net/drobilla#me>
	a foaf:Person ;
	foaf:name "David Robillard" ;
	foaf:homepage <http://drobilla.net/> ;
	foaf:mbox <mailto:d@drobilla.net> ;
	rdfs:seeAlso <http://drobilla.net/drobilla> .

<http://lv2plug.in/ns/ext/state>
	a lv2:Specification ;
	doap:name "LV2 State" ;
	doap:shortdesc "An interface for LV2 plugins to save and restore state." ;
	doap:license <http://opensource.org/licenses/isc> ;
	doap:release [
		doap:revision "0.5" ;
		doap:created "2012-01-29" ;
		dcs:blame <http://drobilla.net/drobilla#me>
	] ;
	doap:developer [
		a foaf:Person ;
		foaf:name "Leonard Ritter" ;
		foaf:homepage <http://paniq.org>
	] ;
	doap:maintainer [
		a foaf:Person ;
		foaf:name "David Robillard" ;
		foaf:homepage <http://drobilla.net/> ;
		rdfs:seeAlso <http://drobilla.net/drobilla.rdf>
	] ;
	lv2:documentation """
<p>This extension provides a simple mechanism for plugins to save and restore
state across instances, allowing hosts to save and restore a plugin instance's
state at any time.  The goal is for an instance's state to be
<em>completely</em> described by port values (as with all LV2 plugins) and a
dictionary.</p>

<p>The <q>state</q> described by this extension is conceptually a simple
key:value dictionary, where keys are URIDs (URIs mapped to integers) and values
are type-tagged blobs of any type.  A single key:value pair is called a
<q>property</q>.  To implement state, the plugin provides a state:Interface to
the host.  To save or restore, the host calls LV2_State_Interface::save() or
LV2_State_Interface::restore(), passing a callback to be used for handling a
single property.  The host is free to implement property storage and retrieval
in any way.</p>

<p>This state model is simple yet has many benefits:</p>
<ul>
  <li>URID keys provide both fast performance and RDF compatibility.</li>
  <li>Fully extensible, no limitations on keys or value types.</li>
  <li>Easy to serialise in many formats (e.g. any RDF syntax, plain
  text, JSON, XML, key:value databases, SQL, s-expressions, etc.).</li>
  <li>Elegantly described in Turtle, which is useful for describing presets
  or default state in LV2 data files (the predicate state:state is provided
  for this purpose).</li>
  <li>Does not impose any file formats, data structures, or file system
  requirements.</li>
  <li>Suitable for portable persistent state as well as fast in-memory
  snapshots.</li>
  <li>Easily stored in a typical <q>map</q> or <q>dictionary</q> data
  structure.</li>
  <li>Keys may be defined by extensions and used by several plugins,
  making state meaningful enabling dynamic state control.</li>
</ul>

<p>Implementations or further extensions which work with plugin state
(including dynamic plugin control) SHOULD work entirely within this model.
That is, <strong>do not complicate the state model</strong>.  <em>All</em>
information required to express an instance's state at any given time can, and
should, be expressed within this model.</p>

<h3>Plugin Code Example</h3>

<pre class="c-code">
#define NS_EG   "http://example.org/"
#define NS_ATOM "http://lv2plug.in/ns/ext/atom#"

LV2_Handle my_instantiate(...)
{
    MyPlugin* plugin = ...;
    plugin->uris.atom_String = map_uri(NS_ATOM "String");
    plugin->uris.eg_greeting = map_uri(NS_EG "greeting");
    plugin->state.greeting   = strdup("Hello");
    return plugin;
}

void my_save(LV2_Handle                 instance,
             LV2_State_Store_Function   store,
             void*                      handle,
             uint32_t                   flags,
             const LV2_Feature *const * features)
{
    MyPlugin*   plugin   = (MyPlugin*)instance;
    const char* greeting = plugin->state.greeting;

    store(handle,
          plugin->uris.eg_greeting,
          greeting,
          strlen(greeting) + 1,
          plugin->uris.atom_String,
          LV2_STATE_IS_POD | LV2_STATE_IS_PORTABLE);
}

void my_restore(LV2_Handle                  instance,
                LV2_State_Retrieve_Function retrieve,
                void*                       handle,
                uint32_t                    flags,
                const LV2_Feature *const *  features)
{
    MyPlugin* plugin = (MyPlugin*)instance;

    size_t      size;
    uint32_t    type;
    uint32_t    flags;
    const char* greeting = retrieve(
        handle, plugin->uris.eg_greeting, &amp;size, &amp;type, &amp;flags);

    if (greeting) {
        free(plugin->state->greeting);
        plugin->state->greeting = strdup(greeting);
    } else {
        plugin->state->greeting = strdup("Hello");
    }
}

const void* my_extension_data(const char* uri)
{
    static const LV2_State_Interface state_iface = { my_save, my_restore };
    if (!strcmp(uri, LV2_STATE_INTERFACE_URI)) {
        return &amp;state_iface;
    }
}
</pre>

<h3>Host Code Example</h3>

<pre class="c-code">
int store_callback(void*       handle,
                   uint32_t    key,
                   const void* value,
                   size_t      size,
                   uint32_t    type,
                   uint32_t    flags)
{
    if ((flags &amp; LV2_STATE_IS_POD)) {
        /* We only care about POD since we're keeping state in memory only.
           If this was for disk or network storage/transmission,
           LV2_STATE_IS_PORTABLE would have to be checked as well.
        */
        Map* state_map = (Map*)handle;
        state_map->insert(key, Value(copy(value), size, type, pod));
        return 0;
    } else {
        return 1; /* Non-POD events are unsupported. */
    }
}

Map get_plugin_state(LV2_Handle instance)
{
    LV2_State* state = instance.extension_data("http://lv2plug.in/ns/ext/state");
    Map state_map;
    /** Request a fast/native/POD save, since we're just copying in memory */
    state.save(instance, store_callback, &amp;state_map,
               LV2_STATE_IS_POD|LV2_STATE_IS_NATIVE);
    return state_map;
}
</pre>

<h3>Referring to Existing Files</h3>

<p>Plugins may need to refer to files (e.g. loaded samples) in their state.
This is done by storing the file's path as a property just like any other
value.  However, there are some rules which MUST be followed when storing
paths, see <a href="#mapPath">state:mapPath</a> for details.  Plugins MUST
use the type <a href="http://lv2plug.in/ns/ext/atom#Path">atom:Path</a>
for all paths in their state.</p>

<h3>Creating New Files or Directories</h3>

<p>Implementations are strongly encouraged to avoid the use of files and simply
store all state as properties whenever possible.  However, occasionally the
ability to create files is necessary.  The feature <a
href="#newPath">state:newPath</a> makes this possible, if it is provided by the
host.</p>
""" .

state:Interface
	a rdfs:Class ;
	rdfs:subClassOf lv2:ExtensionData ;
	lv2:documentation """
<p>A structure (LV2_State_Interface) which contains functions to be called by
the host to save and restore state.  In order to support this extension, the
plugin must return a valid LV2_State_Interface from
LV2_Descriptor::extension_data() when it is called with
LV2_STATE_INTERFACE_URI.</p>

<p>The plugin data file should describe this like so:</p>
<pre class="turtle-code">
@prefix state: &lt;http://lv2plug.in/ns/ext/state#&gt; .

&lt;plugin&gt;
    a lv2:Plugin ;
    lv2:extensionData state:Interface .
</pre>
""" .

state:State
	a rdfs:Class ;
	rdfs:label "Plugin Instance State" ;
	lv2:documentation """
<p>This class is used to express a plugin instance's state in RDF. The
key/value properties of the instance form the predicate/object (respectively)
of triples with a state:State as the subject (see <a
href="#state">state:state</a> for an example). This may be used wherever it is
useful to express a plugin instance's state in RDF (e.g. for serialisation,
storing in a model, or transmitting over a network). Note that this class is
provided because it may be useful for hosts, plugins, or extensions that work
with instance state, but its use is not required to support the LV2 State
extension.</p>
""" .

state:state
	a rdf:Property ;
	rdfs:range state:State ;
	lv2:documentation """
<p>Predicate to relate a plugin instance to its State.  This may be used
wherever the state of a particular plugin instance needs to be represented.
Note that the domain of this property is unspecified, since LV2 does not define
any RDF class for plugin instance. This predicate may be used wherever it makes
sense to do so, e.g.:</p>
<pre class="turtle-code">
@prefix eg: &lt;http://example.org/&gt; .

&lt;plugininstance&gt;
    state:state [
        eg:somekey "some value" ;
        eg:someotherkey "some other value" ;
        eg:favourite-number 2
    ] .
</pre>
<p>Note that this property is provided because it may be useful for hosts,
plugins, or extensions that work with instance state, but its use is not
required to support this extension.</p>
""" .

state:mapPath
	a lv2:Feature ;
	rdfs:label "Support for storing paths in files" ;
	lv2:documentation """
<p>This feature maps absolute paths to/from <q>abstract paths</q> which are
stored in state.  To support this feature a host must pass an LV2_Feature with
URI LV2_STATE_MAP_PATH_URI and data pointed to an LV2_State_Map_Path to the
plugin's LV2_State_Interface methods.</p>

<p>The plugin MUST map <em>all</em> paths stored in its state (including in any
files in its state).  This is necessary to enable host to handle file system
references correctly, e.g. for distribution or archival.</p>

<p>For example, a plugin may write a path to a state file like so:</p>

<pre class="c-code">
void write_path(LV2_State_Map_Path* map_path, FILE* myfile, const char* path)
{
    char* abstract_path = map_path->abstract_path(map_path->handle, path);
    fprintf(myfile, "%s", abstract_path);
    free(abstract_path);
}
</pre>

<p>Then, later reload the path like so:</p>

<pre class="c-code">
char* read_path(LV2_State_Map_Path* map_path, FILE* myfile)
{
    /* Obviously this is not production quality code! */
    char abstract_path[1024];
    fscanf(myfile, "%s", abstract_path);
    return map_path->absolute_path(map_path->handle, abstract_path);
}
</pre>
""" .

state:makePath
	a lv2:Feature ;
	rdfs:label "Support for creating new files and directories" ;
	lv2:documentation """
<p>This feature allows plugins to create new files and/or directories.  To
support this feature the host passes an LV2_Feature with URI
LV2_STATE_MAKE_PATH_URI and data pointed to an LV2_State_Make_Path to the
plugin.  The host may make this feature available only during save by passing
it to LV2_State_Interface::save(), or available any time by passing it to
LV2_Descriptor::instantiate().  If passed to LV2_State_Interface::save(), the
feature MUST NOT be used beyond the scope of that call.</p>

<p>The plugin is guaranteed a hierarchial namespace unique to that plugin
instance, and may expect the returned path to have the requested path as a
suffix.  There is <em>one</em> such namespace, even if the feature is passed to
both LV2_Descriptor::instantiate() <em>and</em>
LV2_State_Interface::save().  Beyond this, the plugin MUST NOT make any
assumptions about the returned paths.</p>

<p>Like any other paths, the plugin MUST map these paths using <a
href="#mapPath">state:mapPath</a> before storing them in state.  The plugin
MUST NOT assume these paths will be available across a save/restore otherwise,
i.e.  only mapped paths saved to state are persistent, any other created paths
are temporary.</p>

<p>For example, a plugin may create a file in a subdirectory like so:</p>

<pre class="c-code">
char* save_myfile(LV2_State_Make_Path* make_path)
{
    char* path   = make_path->path(make_path->handle, "foo/bar/myfile.txt");
    FILE* myfile = fopen(path, 'w');
    fprintf(myfile, "Hello");
    fclose(myfile);
    return path;
}
</pre>
""" .
