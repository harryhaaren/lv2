# LV2 State Extension
# Copyright 2010-2011 David Robillard <d@drobilla.net>
# Copyright 2010 Leonard Ritter <paniq@paniq.org>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THIS SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

@prefix state: <http://lv2plug.in/ns/ext/state#> .
@prefix doap:  <http://usefulinc.com/ns/doap#> .
@prefix foaf:  <http://xmlns.com/foaf/0.1/> .
@prefix lv2:   <http://lv2plug.in/ns/lv2core#> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .

<http://lv2plug.in/ns/ext/state>
    a lv2:Specification ;
    doap:name "LV2 State" ;
    doap:shortdesc "An interface for LV2 plugins to save and restore state." ;
    doap:license <http://opensource.org/licenses/isc-license> ;
    doap:release [
        doap:revision "0.2" ;
        doap:created "2011-11-14"
    ] ;
    doap:developer [
        a foaf:Person ;
        foaf:name "Leonard Ritter" ;
        foaf:homepage <http://paniq.org> ;
    ] ;
    doap:maintainer [
        a foaf:Person ;
        foaf:name     "David Robillard" ;
        foaf:homepage <http://drobilla.net/> ;
        rdfs:seeAlso  <http://drobilla.net/drobilla.rdf>
    ] ;
    lv2:documentation """
<p>This extension provides a mechanism for plugins to save and restore state
across instances, allowing hosts to save, restore, clone, or take a snapshot of
a plugin instance's state at any point in time.  The intention is for a plugin
instance's state to be <em>completely</em> described by port values (as with all
LV2 plugins) and a simple dictionary.</p>

<p>The <q>state</q> described by this extension is conceptually a single
key/value dictionary, where keys are URIDs and values are type-tagged blobs of
any type.  The plugin provides an LV2_State_Interface for working with this
state.  To save or restore, the host calls LV2_State_Interface::save() or
LV2_State_Interface::restore(), passing a callback to be used for handling a
single key/value pair.  The host is free to implement saving and restoring in
any way; the actual mechanism is completely abstract from the plugin's
perspective.</p>

<p>Because state is a simple dictionary, hosts and plugins can work with it
easily from many languages and protocols.  Keys are URIDs for performance
reasons as well as RDF compatibility, which makes it simple to serialise state
in many formats (e.g. any RDF syntax, JSON, XML, key/value databases such as
BDB, etc.).  In particular, state can be elegantly described in a plugin's
Turtle description, which is useful for e.g. presets or default state.
Specific keys may be described in Turtle on the fly or in extensions,
allowing plugins to use common well-defined keys.</p>

<p>This extension defines a conceptual model of state and a mechanism for
saving and restoring it, but no interface for manipulating it dynamically.
While no such mechanism is defined here, dynamic control of plugins SHOULD be
achieved by generic manipulations of the same conceptual state dictionary used
by this extension (e.g. <code>plugin->set(key, value)</code>).  Accordingly,
plugins SHOULD use meaningful and well-defined keys wherever possible.</p>

<p>In pseudo code, a typical use case in a plugin is:</p>
<pre class="c-code">
#define NS_EG   "http://example.org/"
#define NS_ATOM "http://lv2plug.in/ns/ext/atom#"

LV2_Handle my_instantiate(...)
{
    MyPlugin* plugin = ...;
    plugin->uris.atom_String = map_uri(NS_ATOM "String");
    plugin->uris.eg_greeting = map_uri(NS_EG "greeting");
    plugin->state.greeting   = strdup("Hello");
    return plugin;
}

void my_save(LV2_Handle                 instance,
             LV2_State_Store_Function   store,
             void*                      handle,
             uint32_t                   flags,
             const LV2_Feature *const * features)

{
    MyPlugin*   plugin   = (MyPlugin*)instance;
    const char* greeting = plugin->state.greeting;

    store(handle,
          plugin->uris.eg_greeting,
          greeting,
          strlen(greeting) + 1,
          plugin->uris.atom_String,
          LV2_STATE_IS_POD | LV2_STATE_IS_PORTABLE);
}

void my_restore(LV2_Handle                  instance,
                LV2_State_Retrieve_Function retrieve,
                void*                       handle,
                uint32_t                    flags,
                const LV2_Feature *const *   features)
{
    MyPlugin* plugin = (MyPlugin*)instance;

    size_t      size;
    uint32_t    type;
    uint32_t    flags;
    const char* greeting = retrieve(handle,
                                    plugin->uris.eg_greeting,
                                    &amp;size,
                                    &amp;type,
                                    &amp;flags);

    if (greeting) {
        free(plugin->state->greeting);
        plugin->state->greeting = strdup(greeting);
    } else {
        plugin->state->greeting = strdup("Hello");
    }
}

const void* my_extension_data(const char* uri)
{
    static const LV2_State_Interface state_iface = { my_save, my_restore };
    if (!strcmp(uri, LV2_STATE_INTERFACE_URI)) {
        return &amp;state_iface;
    }
}
</pre>

<p>Similarly, a typical use case in a host is:</p>
<pre class="c-code">
int store_callback(void*       handle,
                   uint32_t    key,
                   const void* value,
                   size_t      size,
                   uint32_t    type,
                   uint32_t    flags)
{
    if ((flags &amp; LV2_STATE_IS_POD)) {
        /* We only care about POD since we're keeping state in memory only.
           If this was for disk or network storage/transmission,
           LV2_STATE_IS_PORTABLE would have to be checked as well.
        */
        Map* state_map = (Map*)handle;
        state_map->insert(key, Value(copy(value), size, type, pod));
        return 0;
    } else {
        return 1; /* Non-POD events are unsupported. */
    }
}

Map get_plugin_state(LV2_Handle instance)
{
    LV2_State* state = instance.extension_data("http://lv2plug.in/ns/ext/state");
    Map state_map;
    /** Request a fast/native/POD save, since we're just copying in memory */
    state.save(instance, store_callback, &amp;state_map,
               LV2_STATE_IS_POD|LV2_STATE_IS_NATIVE);
    return state_map;
}
</pre>
""" .

state:Interface
    a rdfs:Class ;
    rdfs:subClassOf lv2:ExtensionData ;
    lv2:documentation """
<p>A structure (LV2_State_Interface) which contains functions to be called by
the host to save and restore state.  In order to support this extension, the
plugin must return a valid LV2_State_Interface from
LV2_Descriptor::extension_data() when it is called with
LV2_STATE_INTERFACE_URI.</p>

<p>The plugin data file should describe this like so:</p>
<pre class="turtle-code">
@prefix state: &lt;http://lv2plug.in/ns/ext/state#&gt; .

&lt;plugin&gt;
    a lv2:Plugin ;
    lv2:extensionData state:Interface .
</pre>
""" .

state:InstanceState
    a rdfs:Class ;
    rdfs:label "Plugin Instance State" ;
    rdfs:comment """
This class is used to express a plugin instance's state in RDF. The key/value
properties of the instance form the predicate/object (respectively) of triples
with a state:InstanceState as the subject (see state:instanceState for an
example). This may be used wherever it is useful to express a plugin instance's
state in RDF (e.g. for serialisation, storing in a model, or transmitting over
a network). Note that this class is provided because it may be useful for
hosts, plugins, or extensions that work with instance state, but its use is not
required to support the LV2 State extension.
""" .

state:instanceState
    a rdf:Property ;
    rdfs:range state:InstanceState ;
    lv2:documentation """
<p>Predicate to relate a plugin instance to an InstanceState. This may be used
wherever the state of a particular plugin instance needs to be represented.
Note that the domain of this property is unspecified, since LV2 does not define
any RDF class for plugin instance. This predicate may be used wherever it makes
sense to do so, e.g.:</p>
<pre class="turtle-code">
@prefix eg: &lt;http://example.org/&gt; .

&lt;plugininstance&gt; state:instanceState [
    eg:somekey "some value" ;
    eg:someotherkey "some other value" ;
    eg:favourite-number 2
] .
</pre>
<p>Note that this property is provided because it may be useful for hosts,
plugins, or extensions that work with instance state, but its use is not
required to support the LV2 State extension.</p>
""" .
