# LV2 Persist Extension
# Copyright 2010-2011 David Robillard <d@drobilla.net>
# Copyright 2010 Leonard Ritter <paniq@paniq.org>
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

@prefix persist: <http://lv2plug.in/ns/ext/persist#> .
@prefix doap:    <http://usefulinc.com/ns/doap#> .
@prefix foaf:    <http://xmlns.com/foaf/0.1/> .
@prefix lv2:     <http://lv2plug.in/ns/lv2core#> .
@prefix rdf:     <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:    <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .

<http://lv2plug.in/ns/ext/persist>
    a lv2:Specification ;
    doap:name "LV2 Persist" ;
    doap:release [
        doap:revision "0.3" ;
        doap:created "2011-03-29"
    ] ;
    doap:developer [
        a foaf:Person ;
        foaf:name "Leonard Ritter" ;
        foaf:homepage <http://paniq.org> ;
    ] ;
    doap:maintainer [
        a foaf:Person ;
        foaf:name     "David Robillard" ;
        foaf:homepage <http://drobilla.net/> ;
        rdfs:seeAlso  <http://drobilla.net/drobilla.rdf>
    ] ;
    lv2:documentation """
<p>This extension provides a mechanism for plugins to save and restore state
across instances, allowing hosts to save configuration/state/data with a
project or fully clone (i.e. make a deep copy of) a plugin instance.</p>

<p>This extension allows plugins to save private state data, i.e. data that is
not contained in input ports. The motivating ideal is for the state of a plugin
instance to be <em>entirely</em> described by port values (as with all LV2
plugins) and a key/value dictionary as defined by this extension. This
mechanism is simple, yet sufficiently powerful to describe arbitrarily advanced
state.</p>

<p>The <q>state</q> described by this extension is conceptually a single key/value
dictionary. Keys are URIs, and values are typed-tagged blobs of any type. The
plugin provides a save and restore method for saving and restoring state. To
initiate a save or restore, the host calls these methods, passing a callback to
be used for saving or restoring a key/value pair. This data is available
to the host, allowing state to be easily used in many different way. The
actual mechanism of saving and restoring state is completely abstract from the
plugin's perspective.</p>

<p>Because the state is a simple dictionary, hosts and plugins can work with
state easily (virtually all programming languages have an appropriate
dictionary type available). Additionally, this format is simple and terse to
serialise in many formats (e.g. any RDF syntax, JSON, XML, key/value databases
such as BDB, etc.). In particular, state can be elegantly described in a
plugin's Turtle description, which is useful for e.g. presets or default
state. Note that these are simply possibilities; this extension defines only a
few function prototypes and does not require the use of any particular syntax,
data structure, file system, or other implementation detail. Hosts are free to
work with plugin state in whatever way is most appropriate for that host.</p>

<p>This extension makes it possible for plugins to save private data, but state
is not necessarily private, e.g. a plugin could have a public interface for
inspecting and manipulating internal state, which would be saved using this
extension. Plugins and extensions SHOULD express state changes as modifications
to this key/value dictionary, and use meaningful types wherever
possible. Extensions may define a dynamic mechanism for accessing plugin state,
or conventional state keys likely to be useful to several implementations.</p>

<p>In pseudo code, a typical use case in a plugin is:</p>
<pre>
#define NS_EG   "http://example.org/"
#define NS_ATOM "http://lv2plug.in/ns/ext/atom#"
#define NS_XSD  "http://www.w3.org/2001/XMLSchema#"

static const char* const KEY_GREETING = "http://example.org/greeting";

LV2_Handle my_instantiate(...)
{
    MyPlugin*            plugin = ...;
    LV2_URI_Map_Feature* map    = ...;
    plugin->uri_greeting_key = map->uri_to_id(..., NULL, NS_EG "greeting-key");
    plugin->uri_xsd_string   = map->uri_to_id(..., NULL, NS_XSD "string");
    plugin->state->greeting  = strdup("Hello");
    return plugin;
}

void my_save(LV2_Handle                 instance,
             LV2_Persist_Store_Function store,
             void*                      callback_data)
{
    MyPlugin*   plugin   = (MyPlugin*)instance;
    const char* greeting = plugin->state->greeting;

    store(callback_data,
          plugin->uri_greeting_key,
          greeting,
          strlen(greeting) + 1,
          plugin->uri_xsd_string,
          LV2_PERSIST_IS_POD | LV2_PERSIST_IS_PORTABLE);
}

void my_restore(LV2_Handle                    instance,
                LV2_Persist_Retrieve_Function retrieve,
                void*                         callback_data)
{
    MyPlugin* plugin = (MyPlugin*)instance;

    size_t      size;
    uint32_t    type;
    uint32_t    flags;
    const char* greeting = retrieve(callback_data,
                                    plugin->uri_greeting_key,
                                    &amp;size,
                                    &amp;type,
                                    &amp;flags);

    if (greeting) {
        free(plugin->state->greeting);
        plugin->state->greeting = strdup(greeting);
    } else {
        plugin->state->greeting = strdup("Hello");
    }
}
</pre>

<p>Similarly, a typical use case in a host is:</p>
<pre>
int store_callback(void*       callback_data,
                   uint32_t    key,
                   const void* value,
                   size_t      size,
                   uint32_t    type,
                   uint32_t    flags)
{
    if ((flags & LV2_PERSIST_IS_POD)) {
        /* Keeping state in memory only, if disk was involved then
           LV2_PERSIST_IS_PORTABLE would have to be checked as well.
        */
        Map* state_map = (Map*)callback_data;
        state_map->insert(key, Value(copy(value), size, type, pod));
        return 0;
    } else {
        return 1; /* Non-POD events are unsupported. */
    }
}

Map get_plugin_state(LV2_Handle instance)
{
    LV2_Persist* persist = instance.extension_data("http://lv2plug.in/ns/ext/persist");
    Map state_map;
    persist.save(instance, store_callback, &amp;state_map);
    return state_map;
}
</pre>
""" .

persist:InstanceState
    a rdfs:Class ;
    rdfs:label "Plugin Instance State" ;
    rdfs:comment """
This class is used to express a plugin instance's state in RDF. The key/value
properties of the instance form the predicate/object (respectively) of triples
with a persist:InstanceState as the subject (see persist:instanceState for an
example). This may be used wherever it is useful to express a plugin instance's
state in RDF (e.g. for serialisation, storing in a model, or transmitting over
a network). Note that this class is provided because it may be useful for
hosts, plugins, or extensions that work with instance state, but its use is not
required to support the LV2 Persist extension.
""" .


persist:instanceState
    a rdf:Property ;
    rdfs:range persist:InstanceState ;
    lv2:documentation """
Predicate to relate a plugin instance to an InstanceState. This may be used
wherever the state of a particular plugin instance needs to be represented.
Note that the domain of this property is unspecified, since LV2 does not define
any RDF class for plugin instance. This predicate may be used wherever it makes
sense to do so, e.g.:
<pre>
@prefix eg: &lt;http://example.org/&gt; .

&lt;plugininstance&gt; persist:instanceState [
    eg:somekey "some value" ;
    eg:someotherkey "some other value" ;
    eg:favourite-number 2 .
]
</pre>
Note that this property is provided because it may be useful for hosts,
plugins, or extensions that work with instance state, but its use is not
required to support the LV2 Persist extension.
""" .
